// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: git_organization.sql

package queries

import (
	"context"
)

const createOrUpdateGitOrganization = `-- name: CreateOrUpdateGitOrganization :one
INSERT INTO git_organization (provider, provider_id, name, avatar_url)
VALUES ($1, $2, $3, $4)
ON CONFLICT (provider, provider_id) DO UPDATE
    SET provider    = $1,
        provider_id = $2,
        name        = $3,
        avatar_url  = $4
RETURNING id, provider, provider_id, name, avatar_url, installation_id
`

type CreateOrUpdateGitOrganizationParams struct {
	Provider   string
	ProviderID string
	Name       string
	AvatarUrl  *string
}

func (q *Queries) CreateOrUpdateGitOrganization(ctx context.Context, arg CreateOrUpdateGitOrganizationParams) (GitOrganization, error) {
	row := q.db.QueryRow(ctx, createOrUpdateGitOrganization,
		arg.Provider,
		arg.ProviderID,
		arg.Name,
		arg.AvatarUrl,
	)
	var i GitOrganization
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.AvatarUrl,
		&i.InstallationID,
	)
	return i, err
}

const findAllUserOrganizationIds = `-- name: FindAllUserOrganizationIds :many
SELECT git_organization_id
FROM user_git_organization
WHERE user_id = $1
`

func (q *Queries) FindAllUserOrganizationIds(ctx context.Context, userID int64) ([]int64, error) {
	rows, err := q.db.Query(ctx, findAllUserOrganizationIds, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var git_organization_id int64
		if err := rows.Scan(&git_organization_id); err != nil {
			return nil, err
		}
		items = append(items, git_organization_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGitOrganizationByID = `-- name: FindGitOrganizationByID :one
SELECT id, provider, provider_id, name, avatar_url, installation_id
FROM git_organization
WHERE id = $1
`

func (q *Queries) FindGitOrganizationByID(ctx context.Context, id int64) (GitOrganization, error) {
	row := q.db.QueryRow(ctx, findGitOrganizationByID, id)
	var i GitOrganization
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.AvatarUrl,
		&i.InstallationID,
	)
	return i, err
}

const findGitOrganizationByProviderAndName = `-- name: FindGitOrganizationByProviderAndName :one
SELECT id, provider, provider_id, name, avatar_url, installation_id
FROM git_organization
WHERE provider = $1
  AND name = $2
`

type FindGitOrganizationByProviderAndNameParams struct {
	Provider string
	Name     string
}

func (q *Queries) FindGitOrganizationByProviderAndName(ctx context.Context, arg FindGitOrganizationByProviderAndNameParams) (GitOrganization, error) {
	row := q.db.QueryRow(ctx, findGitOrganizationByProviderAndName, arg.Provider, arg.Name)
	var i GitOrganization
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.AvatarUrl,
		&i.InstallationID,
	)
	return i, err
}

const findGitOrganizationByProviderAndUserID = `-- name: FindGitOrganizationByProviderAndUserID :many
SELECT go.id, go.provider, go.provider_id, go.name, go.avatar_url, go.installation_id
FROM git_organization go
         JOIN user_git_organization uo
              ON go.id = uo.git_organization_id
WHERE go.provider = $1
  AND uo.user_id = $2
`

type FindGitOrganizationByProviderAndUserIDParams struct {
	Provider string
	UserID   int64
}

func (q *Queries) FindGitOrganizationByProviderAndUserID(ctx context.Context, arg FindGitOrganizationByProviderAndUserIDParams) ([]GitOrganization, error) {
	rows, err := q.db.Query(ctx, findGitOrganizationByProviderAndUserID, arg.Provider, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GitOrganization
	for rows.Next() {
		var i GitOrganization
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.AvatarUrl,
			&i.InstallationID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findGitOrganizationByRepoId = `-- name: FindGitOrganizationByRepoId :one
SELECT go.id, go.provider, go.provider_id, go.name, go.avatar_url, go.installation_id
FROM git_organization go
         JOIN git_repository gr
              ON go.id = gr.organization_id
WHERE gr.id = $1
`

func (q *Queries) FindGitOrganizationByRepoId(ctx context.Context, id int64) (GitOrganization, error) {
	row := q.db.QueryRow(ctx, findGitOrganizationByRepoId, id)
	var i GitOrganization
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.AvatarUrl,
		&i.InstallationID,
	)
	return i, err
}

const isUserMemberOfOrganization = `-- name: IsUserMemberOfOrganization :one
SELECT EXISTS(SELECT 1
              FROM user_git_organization
              WHERE git_organization_id = $1
                AND user_id = $2)
`

type IsUserMemberOfOrganizationParams struct {
	GitOrganizationID int64
	UserID            int64
}

func (q *Queries) IsUserMemberOfOrganization(ctx context.Context, arg IsUserMemberOfOrganizationParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserMemberOfOrganization, arg.GitOrganizationID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isUserMemberOfOrganizationByRepoId = `-- name: IsUserMemberOfOrganizationByRepoId :one
SELECT EXISTS(SELECT 1
              FROM user_git_organization ugo
                       JOIN git_repository gr
                            ON ugo.git_organization_id = gr.organization_id
              WHERE gr.id = $1
                AND ugo.user_id = $2)
`

type IsUserMemberOfOrganizationByRepoIdParams struct {
	RepoID int64
	UserID int64
}

func (q *Queries) IsUserMemberOfOrganizationByRepoId(ctx context.Context, arg IsUserMemberOfOrganizationByRepoIdParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserMemberOfOrganizationByRepoId, arg.RepoID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateOrgInstallationID = `-- name: UpdateOrgInstallationID :exec
UPDATE git_organization
SET installation_id = $2
WHERE id = $1
`

type UpdateOrgInstallationIDParams struct {
	ID             int64
	InstallationID *int64
}

func (q *Queries) UpdateOrgInstallationID(ctx context.Context, arg UpdateOrgInstallationIDParams) error {
	_, err := q.db.Exec(ctx, updateOrgInstallationID, arg.ID, arg.InstallationID)
	return err
}

const updateUserGitOrganizationMembership = `-- name: UpdateUserGitOrganizationMembership :exec
INSERT INTO user_git_organization (user_id, git_organization_id, role)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, git_organization_id) DO UPDATE
    SET role = $3
`

type UpdateUserGitOrganizationMembershipParams struct {
	UserID            int64
	GitOrganizationID int64
	Role              string
}

func (q *Queries) UpdateUserGitOrganizationMembership(ctx context.Context, arg UpdateUserGitOrganizationMembershipParams) error {
	_, err := q.db.Exec(ctx, updateUserGitOrganizationMembership, arg.UserID, arg.GitOrganizationID, arg.Role)
	return err
}
