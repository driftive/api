// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package queries

import (
	"context"
	"time"
)

const countUsersByProviderAndProviderId = `-- name: CountUsersByProviderAndProviderId :one
SELECT COUNT(*)
FROM users
WHERE provider = $1
  AND provider_id = $2
`

type CountUsersByProviderAndProviderIdParams struct {
	Provider   string
	ProviderID string
}

func (q *Queries) CountUsersByProviderAndProviderId(ctx context.Context, arg CountUsersByProviderAndProviderIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByProviderAndProviderId, arg.Provider, arg.ProviderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const disableTokenRefresh = `-- name: DisableTokenRefresh :one
UPDATE users
SET token_refresh_disabled_at = NOW()
WHERE id = $1 RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
`

func (q *Queries) DisableTokenRefresh(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, disableTokenRefresh, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const findAndLockExpiringToken = `-- name: FindAndLockExpiringToken :one
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
FROM users
WHERE provider = $1
  AND access_token != ''
  AND access_token_expires_at IS NOT NULL
  AND access_token_expires_at < $2
  AND refresh_token_expires_at > NOW() + INTERVAL '1 day'
  AND token_refresh_disabled_at IS NULL
LIMIT 1
FOR UPDATE SKIP LOCKED
`

type FindAndLockExpiringTokenParams struct {
	Provider string
	Date     *time.Time
}

func (q *Queries) FindAndLockExpiringToken(ctx context.Context, arg FindAndLockExpiringTokenParams) (User, error) {
	row := q.db.QueryRow(ctx, findAndLockExpiringToken, arg.Provider, arg.Date)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const findExpiringTokensByProvider = `-- name: FindExpiringTokensByProvider :many
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
FROM users
WHERE provider = $1
  AND access_token != ''
  AND access_token_expires_at IS NOT NULL
  AND access_token_expires_at < $2
  AND refresh_token_expires_at > NOW() + INTERVAL '1 day'
  AND token_refresh_disabled_at IS NULL
LIMIT $4 OFFSET $3
`

type FindExpiringTokensByProviderParams struct {
	Provider    string
	Date        *time.Time
	Queryoffset int32
	Maxresults  int32
}

func (q *Queries) FindExpiringTokensByProvider(ctx context.Context, arg FindExpiringTokensByProviderParams) ([]User, error) {
	rows, err := q.db.Query(ctx, findExpiringTokensByProvider,
		arg.Provider,
		arg.Date,
		arg.Queryoffset,
		arg.Maxresults,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.Username,
			&i.Email,
			&i.AccessToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshToken,
			&i.RefreshTokenExpiresAt,
			&i.TokenRefreshAttempts,
			&i.TokenRefreshDisabledAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
FROM users
WHERE id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const findUserByProviderAndProviderId = `-- name: FindUserByProviderAndProviderId :one
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
FROM users
WHERE provider = $1
  AND provider_id = $2
`

type FindUserByProviderAndProviderIdParams struct {
	Provider   string
	ProviderID string
}

func (q *Queries) FindUserByProviderAndProviderId(ctx context.Context, arg FindUserByProviderAndProviderIdParams) (User, error) {
	row := q.db.QueryRow(ctx, findUserByProviderAndProviderId, arg.Provider, arg.ProviderID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const incrementTokenRefreshAttempts = `-- name: IncrementTokenRefreshAttempts :one
UPDATE users
SET token_refresh_attempts = token_refresh_attempts + 1
WHERE id = $1 RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
`

func (q *Queries) IncrementTokenRefreshAttempts(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, incrementTokenRefreshAttempts, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const updateUserTokens = `-- name: UpdateUserTokens :one
UPDATE users
SET access_token               = $1,
    access_token_expires_at    = $2,
    refresh_token              = $3,
    refresh_token_expires_at   = $4,
    token_refresh_attempts     = 0,
    token_refresh_disabled_at  = NULL
WHERE id = $5 RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
`

type UpdateUserTokensParams struct {
	AccessToken           string
	AccessTokenExpiresAt  *time.Time
	RefreshToken          string
	RefreshTokenExpiresAt *time.Time
	ID                    int64
}

func (q *Queries) UpdateUserTokens(ctx context.Context, arg UpdateUserTokensParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserTokens,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}

const upsertUserOnLogin = `-- name: UpsertUserOnLogin :one
INSERT INTO users (provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token,
                   refresh_token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8,
        $9) ON CONFLICT (provider, provider_id) DO
UPDATE SET
    name = $3,
    username = $4,
    email = $5,
    access_token = $6,
    access_token_expires_at = $7,
    refresh_token = $8,
    refresh_token_expires_at = $9,
    token_refresh_attempts = 0,
    token_refresh_disabled_at = NULL
RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at, token_refresh_attempts, token_refresh_disabled_at
`

type UpsertUserOnLoginParams struct {
	Provider              string
	ProviderID            string
	Name                  string
	Username              string
	Email                 string
	AccessToken           string
	AccessTokenExpiresAt  *time.Time
	RefreshToken          string
	RefreshTokenExpiresAt *time.Time
}

func (q *Queries) UpsertUserOnLogin(ctx context.Context, arg UpsertUserOnLoginParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUserOnLogin,
		arg.Provider,
		arg.ProviderID,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
		&i.TokenRefreshAttempts,
		&i.TokenRefreshDisabledAt,
	)
	return i, err
}
