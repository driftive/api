// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: users.sql

package queries

import (
	"context"
	"time"
)

const countUsersByProviderAndProviderId = `-- name: CountUsersByProviderAndProviderId :one
SELECT COUNT(*)
FROM users
WHERE provider = $1
  AND provider_id = $2
`

type CountUsersByProviderAndProviderIdParams struct {
	Provider   string
	ProviderID string
}

func (q *Queries) CountUsersByProviderAndProviderId(ctx context.Context, arg CountUsersByProviderAndProviderIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByProviderAndProviderId, arg.Provider, arg.ProviderID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token,
                   refresh_token_expires_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8,
        $9) ON CONFLICT (provider, provider_id) DO
UPDATE SET
    name = $3,
    username = $4,
    email = $5,
    access_token = $6,
    access_token_expires_at = $7,
    refresh_token = $8,
    refresh_token_expires_at = $9
RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at
`

type CreateOrUpdateUserParams struct {
	Provider              string
	ProviderID            string
	Name                  string
	Username              string
	Email                 string
	AccessToken           string
	AccessTokenExpiresAt  *time.Time
	RefreshToken          string
	RefreshTokenExpiresAt *time.Time
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser,
		arg.Provider,
		arg.ProviderID,
		arg.Name,
		arg.Username,
		arg.Email,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}

const findExpiringTokensByProvider = `-- name: FindExpiringTokensByProvider :many
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at
FROM users
WHERE provider = $1
  AND access_token_expires_at IS NOT NULL
  AND access_token_expires_at < $2 LIMIT $4
OFFSET $3
`

type FindExpiringTokensByProviderParams struct {
	Provider    string
	Date        *time.Time
	Queryoffset int32
	Maxresults  int32
}

func (q *Queries) FindExpiringTokensByProvider(ctx context.Context, arg FindExpiringTokensByProviderParams) ([]User, error) {
	rows, err := q.db.Query(ctx, findExpiringTokensByProvider,
		arg.Provider,
		arg.Date,
		arg.Queryoffset,
		arg.Maxresults,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.Username,
			&i.Email,
			&i.AccessToken,
			&i.AccessTokenExpiresAt,
			&i.RefreshToken,
			&i.RefreshTokenExpiresAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findUserByID = `-- name: FindUserByID :one
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at
FROM users
WHERE id = $1
`

func (q *Queries) FindUserByID(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, findUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}

const findUserByProviderAndProviderId = `-- name: FindUserByProviderAndProviderId :one
SELECT id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at
FROM users
WHERE provider = $1
  AND provider_id = $2
`

type FindUserByProviderAndProviderIdParams struct {
	Provider   string
	ProviderID string
}

func (q *Queries) FindUserByProviderAndProviderId(ctx context.Context, arg FindUserByProviderAndProviderIdParams) (User, error) {
	row := q.db.QueryRow(ctx, findUserByProviderAndProviderId, arg.Provider, arg.ProviderID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}

const updateUserTokens = `-- name: UpdateUserTokens :one
UPDATE users
SET access_token             = $1,
    access_token_expires_at  = $2,
    refresh_token            = $3,
    refresh_token_expires_at = $4
WHERE id = $5 RETURNING id, provider, provider_id, name, username, email, access_token, access_token_expires_at, refresh_token, refresh_token_expires_at
`

type UpdateUserTokensParams struct {
	AccessToken           string
	AccessTokenExpiresAt  *time.Time
	RefreshToken          string
	RefreshTokenExpiresAt *time.Time
	ID                    int64
}

func (q *Queries) UpdateUserTokens(ctx context.Context, arg UpdateUserTokensParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserTokens,
		arg.AccessToken,
		arg.AccessTokenExpiresAt,
		arg.RefreshToken,
		arg.RefreshTokenExpiresAt,
		arg.ID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Username,
		&i.Email,
		&i.AccessToken,
		&i.AccessTokenExpiresAt,
		&i.RefreshToken,
		&i.RefreshTokenExpiresAt,
	)
	return i, err
}
