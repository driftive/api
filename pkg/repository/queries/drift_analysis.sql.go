// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: drift_analysis.sql

package queries

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDriftAnalysisProject = `-- name: CreateDriftAnalysisProject :one
INSERT INTO drift_analysis_project (drift_analysis_run_id, dir, type, drifted, succeeded, init_output, plan_output)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, drift_analysis_run_id, dir, type, drifted, succeeded, init_output, plan_output
`

type CreateDriftAnalysisProjectParams struct {
	DriftAnalysisRunID uuid.UUID
	Dir                string
	Type               string
	Drifted            bool
	Succeeded          bool
	InitOutput         *string
	PlanOutput         *string
}

func (q *Queries) CreateDriftAnalysisProject(ctx context.Context, arg CreateDriftAnalysisProjectParams) (DriftAnalysisProject, error) {
	row := q.db.QueryRow(ctx, createDriftAnalysisProject,
		arg.DriftAnalysisRunID,
		arg.Dir,
		arg.Type,
		arg.Drifted,
		arg.Succeeded,
		arg.InitOutput,
		arg.PlanOutput,
	)
	var i DriftAnalysisProject
	err := row.Scan(
		&i.ID,
		&i.DriftAnalysisRunID,
		&i.Dir,
		&i.Type,
		&i.Drifted,
		&i.Succeeded,
		&i.InitOutput,
		&i.PlanOutput,
	)
	return i, err
}

const createDriftAnalysisRun = `-- name: CreateDriftAnalysisRun :one
INSERT INTO drift_analysis_run (uuid, repository_id, total_projects, total_projects_drifted, analysis_duration_millis)
VALUES ($1, $2, $3, $4, $5)
RETURNING uuid, repository_id, total_projects, total_projects_drifted, analysis_duration_millis, created_at, updated_at
`

type CreateDriftAnalysisRunParams struct {
	Uuid                   uuid.UUID
	RepositoryID           int64
	TotalProjects          int32
	TotalProjectsDrifted   int32
	AnalysisDurationMillis int64
}

func (q *Queries) CreateDriftAnalysisRun(ctx context.Context, arg CreateDriftAnalysisRunParams) (DriftAnalysisRun, error) {
	row := q.db.QueryRow(ctx, createDriftAnalysisRun,
		arg.Uuid,
		arg.RepositoryID,
		arg.TotalProjects,
		arg.TotalProjectsDrifted,
		arg.AnalysisDurationMillis,
	)
	var i DriftAnalysisRun
	err := row.Scan(
		&i.Uuid,
		&i.RepositoryID,
		&i.TotalProjects,
		&i.TotalProjectsDrifted,
		&i.AnalysisDurationMillis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findDriftAnalysisProjectsByRunId = `-- name: FindDriftAnalysisProjectsByRunId :many
SELECT id, drift_analysis_run_id, dir, type, drifted, succeeded, init_output, plan_output
FROM drift_analysis_project
WHERE drift_analysis_run_id = $1
`

func (q *Queries) FindDriftAnalysisProjectsByRunId(ctx context.Context, driftAnalysisRunID uuid.UUID) ([]DriftAnalysisProject, error) {
	rows, err := q.db.Query(ctx, findDriftAnalysisProjectsByRunId, driftAnalysisRunID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DriftAnalysisProject
	for rows.Next() {
		var i DriftAnalysisProject
		if err := rows.Scan(
			&i.ID,
			&i.DriftAnalysisRunID,
			&i.Dir,
			&i.Type,
			&i.Drifted,
			&i.Succeeded,
			&i.InitOutput,
			&i.PlanOutput,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findDriftAnalysisRunByUUID = `-- name: FindDriftAnalysisRunByUUID :one
SELECT uuid, repository_id, total_projects, total_projects_drifted, analysis_duration_millis, created_at, updated_at
FROM drift_analysis_run
WHERE uuid = $1
`

func (q *Queries) FindDriftAnalysisRunByUUID(ctx context.Context, argUuid uuid.UUID) (DriftAnalysisRun, error) {
	row := q.db.QueryRow(ctx, findDriftAnalysisRunByUUID, argUuid)
	var i DriftAnalysisRun
	err := row.Scan(
		&i.Uuid,
		&i.RepositoryID,
		&i.TotalProjects,
		&i.TotalProjectsDrifted,
		&i.AnalysisDurationMillis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findDriftAnalysisRunsByRepositoryId = `-- name: FindDriftAnalysisRunsByRepositoryId :many
SELECT uuid, repository_id, total_projects, total_projects_drifted, analysis_duration_millis, created_at, updated_at
FROM drift_analysis_run
WHERE repository_id = $1
ORDER BY created_at DESC
OFFSET $2 LIMIT $3
`

type FindDriftAnalysisRunsByRepositoryIdParams struct {
	RepositoryID int64
	Queryoffset  int32
	Maxresults   int32
}

func (q *Queries) FindDriftAnalysisRunsByRepositoryId(ctx context.Context, arg FindDriftAnalysisRunsByRepositoryIdParams) ([]DriftAnalysisRun, error) {
	rows, err := q.db.Query(ctx, findDriftAnalysisRunsByRepositoryId, arg.RepositoryID, arg.Queryoffset, arg.Maxresults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DriftAnalysisRun
	for rows.Next() {
		var i DriftAnalysisRun
		if err := rows.Scan(
			&i.Uuid,
			&i.RepositoryID,
			&i.TotalProjects,
			&i.TotalProjectsDrifted,
			&i.AnalysisDurationMillis,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriftFreeStreak = `-- name: GetDriftFreeStreak :one
WITH ranked_runs AS (
    SELECT
        uuid,
        total_projects_drifted,
        created_at,
        ROW_NUMBER() OVER (ORDER BY created_at DESC) AS rn
    FROM drift_analysis_run
    WHERE repository_id = $1
),
first_drift AS (
    SELECT MIN(rn) AS break_point
    FROM ranked_runs
    WHERE total_projects_drifted > 0
)
SELECT
    COALESCE(
        (SELECT break_point - 1 FROM first_drift WHERE break_point IS NOT NULL),
        (SELECT COUNT(*) FROM ranked_runs)
    )::BIGINT AS streak_count,
    (SELECT created_at FROM ranked_runs WHERE rn = 1) AS last_run_at
`

type GetDriftFreeStreakRow struct {
	StreakCount int64
	LastRunAt   time.Time
}

// Returns the current consecutive run count without drift
func (q *Queries) GetDriftFreeStreak(ctx context.Context, repositoryID int64) (GetDriftFreeStreakRow, error) {
	row := q.db.QueryRow(ctx, getDriftFreeStreak, repositoryID)
	var i GetDriftFreeStreakRow
	err := row.Scan(&i.StreakCount, &i.LastRunAt)
	return i, err
}

const getDriftRateOverTime = `-- name: GetDriftRateOverTime :many
SELECT
    DATE(created_at) AS date,
    COUNT(*)::BIGINT AS total_runs,
    COUNT(*) FILTER (WHERE total_projects_drifted > 0)::BIGINT AS runs_with_drift
FROM drift_analysis_run
WHERE repository_id = $1
  AND created_at >= NOW() - ($2::INTEGER || ' days')::INTERVAL
GROUP BY DATE(created_at)
ORDER BY DATE(created_at) ASC
`

type GetDriftRateOverTimeParams struct {
	RepositoryID int64
	DaysBack     int32
}

type GetDriftRateOverTimeRow struct {
	Date          pgtype.Date
	TotalRuns     int64
	RunsWithDrift int64
}

// Returns daily drift rate data for the specified time range
func (q *Queries) GetDriftRateOverTime(ctx context.Context, arg GetDriftRateOverTimeParams) ([]GetDriftRateOverTimeRow, error) {
	rows, err := q.db.Query(ctx, getDriftRateOverTime, arg.RepositoryID, arg.DaysBack)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDriftRateOverTimeRow
	for rows.Next() {
		var i GetDriftRateOverTimeRow
		if err := rows.Scan(&i.Date, &i.TotalRuns, &i.RunsWithDrift); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestRunForRepository = `-- name: GetLatestRunForRepository :one
SELECT uuid, repository_id, total_projects, total_projects_drifted, analysis_duration_millis, created_at, updated_at
FROM drift_analysis_run
WHERE repository_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetLatestRunForRepository(ctx context.Context, repositoryID int64) (DriftAnalysisRun, error) {
	row := q.db.QueryRow(ctx, getLatestRunForRepository, repositoryID)
	var i DriftAnalysisRun
	err := row.Scan(
		&i.Uuid,
		&i.RepositoryID,
		&i.TotalProjects,
		&i.TotalProjectsDrifted,
		&i.AnalysisDurationMillis,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMeanTimeToResolution = `-- name: GetMeanTimeToResolution :many
WITH project_states AS (
    SELECT
        dap.dir,
        dar.created_at,
        dap.drifted,
        LAG(dap.drifted) OVER (PARTITION BY dap.dir ORDER BY dar.created_at) AS prev_drifted
    FROM drift_analysis_project dap
    JOIN drift_analysis_run dar ON dap.drift_analysis_run_id = dar.uuid
    WHERE dar.repository_id = $1
),
transitions AS (
    SELECT
        dir,
        created_at,
        drifted,
        CASE WHEN (prev_drifted IS NULL OR prev_drifted = false) AND drifted = true THEN created_at END AS drift_start,
        CASE WHEN prev_drifted = true AND drifted = false THEN created_at END AS drift_end
    FROM project_states
),
drift_starts AS (
    SELECT dir, drift_start, ROW_NUMBER() OVER (PARTITION BY dir ORDER BY drift_start) AS start_num
    FROM transitions
    WHERE drift_start IS NOT NULL
),
drift_ends AS (
    SELECT dir, drift_end, ROW_NUMBER() OVER (PARTITION BY dir ORDER BY drift_end) AS end_num
    FROM transitions
    WHERE drift_end IS NOT NULL
),
matched_resolutions AS (
    SELECT
        e.dir,
        s.drift_start,
        e.drift_end AS resolved_at,
        EXTRACT(EPOCH FROM (e.drift_end - s.drift_start)) / 3600 AS hours_to_resolve
    FROM drift_ends e
    JOIN drift_starts s ON e.dir = s.dir AND e.end_num = s.start_num
    WHERE e.drift_end >= NOW() - ($2::INTEGER || ' days')::INTERVAL
)
SELECT
    DATE(resolved_at) AS date,
    COUNT(*)::BIGINT AS resolutions_count,
    AVG(hours_to_resolve) AS avg_hours_to_resolve
FROM matched_resolutions
GROUP BY DATE(resolved_at)
ORDER BY DATE(resolved_at) ASC
`

type GetMeanTimeToResolutionParams struct {
	RepositoryID int64
	DaysBack     int32
}

type GetMeanTimeToResolutionRow struct {
	Date              pgtype.Date
	ResolutionsCount  int64
	AvgHoursToResolve float64
}

// Returns drift resolution times by tracking from when drift STARTED to when it was resolved
// Mark transitions: drift_start when going from not-drifted to drifted, drift_end when going from drifted to not-drifted
// Get drift start times
// Get drift end times
// Match each resolution with its corresponding drift start
func (q *Queries) GetMeanTimeToResolution(ctx context.Context, arg GetMeanTimeToResolutionParams) ([]GetMeanTimeToResolutionRow, error) {
	rows, err := q.db.Query(ctx, getMeanTimeToResolution, arg.RepositoryID, arg.DaysBack)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMeanTimeToResolutionRow
	for rows.Next() {
		var i GetMeanTimeToResolutionRow
		if err := rows.Scan(&i.Date, &i.ResolutionsCount, &i.AvgHoursToResolve); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostFrequentlyDriftedProjects = `-- name: GetMostFrequentlyDriftedProjects :many
SELECT
    dap.dir,
    dap.type,
    COUNT(*) FILTER (WHERE dap.drifted = true)::BIGINT AS drift_count,
    COUNT(*)::BIGINT AS total_appearances
FROM drift_analysis_project dap
JOIN drift_analysis_run dar ON dap.drift_analysis_run_id = dar.uuid
WHERE dar.repository_id = $1
  AND dar.created_at >= NOW() - ($2::INTEGER || ' days')::INTERVAL
GROUP BY dap.dir, dap.type
HAVING COUNT(*) FILTER (WHERE dap.drifted = true) > 0
ORDER BY drift_count DESC
LIMIT $3
`

type GetMostFrequentlyDriftedProjectsParams struct {
	RepositoryID int64
	DaysBack     int32
	MaxResults   int32
}

type GetMostFrequentlyDriftedProjectsRow struct {
	Dir              string
	Type             string
	DriftCount       int64
	TotalAppearances int64
}

// Returns projects ranked by how often they drift (top N)
func (q *Queries) GetMostFrequentlyDriftedProjects(ctx context.Context, arg GetMostFrequentlyDriftedProjectsParams) ([]GetMostFrequentlyDriftedProjectsRow, error) {
	rows, err := q.db.Query(ctx, getMostFrequentlyDriftedProjects, arg.RepositoryID, arg.DaysBack, arg.MaxResults)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMostFrequentlyDriftedProjectsRow
	for rows.Next() {
		var i GetMostFrequentlyDriftedProjectsRow
		if err := rows.Scan(
			&i.Dir,
			&i.Type,
			&i.DriftCount,
			&i.TotalAppearances,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepositoryRunStats = `-- name: GetRepositoryRunStats :one
SELECT
    COUNT(*) AS total_runs,
    COUNT(*) FILTER (WHERE total_projects_drifted > 0) AS runs_with_drift,
    MAX(created_at) AS last_run_at
FROM drift_analysis_run
WHERE repository_id = $1
`

type GetRepositoryRunStatsRow struct {
	TotalRuns     int64
	RunsWithDrift int64
	LastRunAt     interface{}
}

func (q *Queries) GetRepositoryRunStats(ctx context.Context, repositoryID int64) (GetRepositoryRunStatsRow, error) {
	row := q.db.QueryRow(ctx, getRepositoryRunStats, repositoryID)
	var i GetRepositoryRunStatsRow
	err := row.Scan(&i.TotalRuns, &i.RunsWithDrift, &i.LastRunAt)
	return i, err
}
